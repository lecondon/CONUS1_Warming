---
title: "GW_Storage_Analysis"
author: "Laura Condon"
date: "12/26/2018"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir="/Users/laura/Documents/CONUS/Warming_Runs")


#install.packages('rgdal')
rm(list=ls())
library(raster)
library(maptools)
library(fields)
library(RColorBrewer)
library(rgdal)

source("~/Documents/R_Functions/PFB-ReadFcn.R")

plotdir="./Figures_December18/"
dir="./Simulation_Averages"
```

## General setup

Setting up domain variables

```{r domain_setup}
runlist=c(0,2,4)
ylist=4:7
nyear=length(ylist)
nrun=length(runlist)

varlist=c("storage", "LH")

#Domain info 
nx=3342
ny=1888
nval=nx*ny

#make xy arrays
ncell=nx*ny
x=rep(1:nx, ny)
y=rep(1:ny, each=nx)

#Making xy vectors with the UTM coordinates
xll=-1884563.7545319
yll= -605655.0023757
xUTM=x*1000+xll
yUTM=y*1000+yll

# Latent Heat of vaporization 
lvap= 2.5104*10^6 # J/kg n- this is the value for 'hvap' in pfsimulator/clm/clm_varcon.F90 
#to convert from W/m2 to mm/hr
# w/m2= J/(s*m2) 
# LH (j/(s*m2)) / lvap (J/kg) = kg/(m2*s) /(1000 kg/m3) = m *1000 =mm
# so just multiply by 3600/lvap to get mm   
```

Shape files to include
```{r read_shape, results='hide'}
#domainshp=readShapeSpatial("/Users/laura/Documents/CONUS/Shape_Files/Domain_shp/Domain_short.shp")
domainshp=readOGR("/Users/laura/Documents/CONUS/Shape_Files/Domain_shp/Domain_short.shp")
#regshp=readShapeSpatial("/Users/laura/Documents/CONUS/Shape_Files/Regions_shp/Regions_Project.shp")
regshp=readOGR("/Users/laura/Documents/CONUS/Shape_Files/Regions_shp/Regions_Project.shp")
#statshp=readShapeSpatial("/Users/laura/Documents/CONUS/Shape_Files/States/states_epa_project.shp")
statshp=readOGR("/Users/laura/Documents/CONUS/CONUS-GIS/States/states_epa_project.shp")
#greatlakes=readShapeSpatial("/Users/laura/Documents/CONUS/Shape_Files/GreatLakes/great_lakes", proj4string=CRS("+proj=merc +lon_0=0 +lat_ts=0 +x_0=0 +y_0=0 +a=6378137 +b=6378137 +units=m +no_defs"))
#greatlakes=readOGR("/Users/laura/Documents/CONUS/Shape_Files/GreatLakes/great_lakes.shp", p4s=CRS("+proj=merc +lon_0=0 +lat_ts=0 +x_0=0 +y_0=0 +a=6378137 +b=6378137 +units=m +no_defs"))
#Project to UTM
#greatlakesUTM=spTransform(greatlakes,CRS("+proj=lcc +lat_1=33 +lat_2=45 +lat_0=39 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs "))

```

Setting up HUCS
```{r HUC_setup}
##########################################
#Merge US and Canadian HUCs and format into a vector for grouping
#Read in the HUCS
#NOTE- These are the older text files the HUC8 didn't line up perfectly with the USGS gdb file I had and they were cut off at the US border so I remade the HUC8 raster in QGIS in the CONUS_Warming.qgs workspace in this main directory. 
#HUC8=matrix(scan("/Users/laura/Documents/CONUS/Domain_TextFiles/HUC_8.format.txt", skip=1))
#HUC4=matrix(scan("/Users/laura/Documents/CONUS/Domain_TextFiles/HUC_4.format.txt", skip=1))
HUCrast=raster("/Users/laura/Documents/CONUS/CONUS-GIS/HUC8/HUC8_Clip_Raster.tif")
HUCmat=as.matrix(HUCrast)
HUC8=rep(0, nx*ny)
kk=1
for(j in ny:1){
  for(i in 1:nx){
    HUC8[kk]=HUCmat[j,i]
    kk=kk+1
  }	
}
HUC=HUC8 #choosing which HUC to work with

#plottemp=HUC
#maxz=150
#minz=0
#plottemp[which(plottemp>maxz)]=maxz
#plottemp[which(plottemp<minz)]=minz
#rastertemp1=rasterFromXYZ(cbind(xUTM, yUTM, plottemp))
#plot(rastertemp1, maxpixels=(nx*ny*10), colNA='lightblue',  col=rev(brewer.pal(name="Spectral", n=11)), legend=T, main="HUC_map", axes=F, zlim=c(minz, maxz))


# Create a combined HUC file with the Candian NHN files
CanNHN=raster("/Users/laura/Documents/CONUS/CONUS-GIS/NHN_INDEX_WORKUNIT_LIMIT_2/NHN_Raster_Temp.tif")
Canmat=as.matrix(CanNHN)
NHN_vec=rep(0, nx*ny)
kk=1
for(j in ny:1){
  for(i in 1:nx){
    NHN_vec[kk]=Canmat[j,i]
    kk=kk+1
  }	
}

HUC_Merge=HUC
#fixlist=which(HUC==(-999) & NHN_vec>0) #for previous HUC matrix where where the NAs were -999
fixlist=which(HUC==(0) & NHN_vec>0) 
HUC_Merge[fixlist]=NHN_vec[fixlist]+3000 #I created a numbering system for the canadian HUCS starting counting at 10 so I'm adding 3000 here so the Canadian numbers don't overlap with the US ones
#rastertemp1=rasterFromXYZ(cbind(xUTM, yUTM,HUC_Merge))
#plot(rastertemp1, maxpixels=(nx*ny*10), colNA='lightblue',  col=rev(brewer.pal(name="Spectral", n=11)), legend=T, main="Baseline PET", axes=F, zlim=c(0,4400))

```

## Reading Inputs
Read Precipitation
```{r precip_read}
fin="/Users/laura/Documents/CONUS/Transient_Runs/Forcing_Averages/precip.yearly.bin"
to.read = file(fin, "rb")
header=readBin(to.read, integer(), endian = "little", size=4, n=3)
precip=readBin(to.read, double(), endian = "little", size=8, n=nval)
close(to.read)

#Units of precip are mm/s and the yearly file is average
precipmm=precip*3600
```

Read Porosity:
```{r porosity_read}
porosity=readpfb("/Users/laura/Documents/CONUS/Warming_Runs/Simulation_Averages/CONUS.5layer.pfclm.PumpHS.run4.out.porosity.pfb", verbose=F)
porosity1=as.vector(porosity[,,5])
#rm(porosity)
#image.plot(porosity1)
```

Read Annual LH Flux:
```{r LH_read}
#########################
#Reading inputs
#Read in the LH flux data - this is annual average [w/m2]
lh=array(NA, dim=c(nval, nyear, nrun))
for(r in 1:nrun){
	print(r)
	for(y in 1:nyear){
		print(paste("Year:", y))
		
		fin=sprintf("%s/Temp%d_Year%d/LH.yearly.bin", dir,runlist[r], ylist[y])
		print(fin)
		to.read = file(fin, "rb")
		header=readBin(to.read, integer(), endian = "little", size=4, n=3)
		lh[,y,r]=readBin(to.read, double(), endian = "little", size=8, n=nval)
		close(to.read)	
	} #end for y
} #end for r

#convert from annual average W/m2
lhmm=lh/lvap*3600*24*365 

#Get the simulation totals
lhmm_tot=matrix(NA, nrow=nval, ncol=nrun)
for(r in 1:nrun){ 
	lhmm_tot[,r]=apply(lhmm[,,r], 1, sum )
}

```

Read Annual Soil Moisture:
```{r SM_read}
sm=array(NA, dim=c(nval, nyear, nrun))
for(r in 1:nrun){
	print(r)
	for(y in 1:nyear){
		print(paste("Year:", y))
		
		fin=sprintf("%s/Temp%d_Year%d/SM.yearly.bin", dir,runlist[r], ylist[y])
		print(fin)
		to.read = file(fin, "rb")
		header=readBin(to.read, integer(), endian = "little", size=4, n=3)
		sm[,y,r]=readBin(to.read, double(), endian = "little", size=8, n=nval)
		close(to.read)	
	} #end for y
} #end for r

```

Read Ending storage:
```{r stor_read}
#Read in the year end storage - month 12 average storage m3
storend=array(NA, dim=c(nval, nyear, nrun))
for(r in 1:nrun){
	print(r)
	for(y in 1:nyear){
		print(paste("Year:", y))
		
		fin=sprintf("%s/Temp%d_Year%d/storage.monthly.12.bin", dir,runlist[r], ylist[y])
		print(fin)
		to.read = file(fin, "rb")
		header=readBin(to.read, integer(), endian = "little", size=4, n=3)
		storend[,y,r]=readBin(to.read, double(), endian = "little", size=8, n=nval)
		close(to.read)	
	} #end for y
} #end for r

storendmm=storend/(1000^2)*1000 #convert from m^3 to mm
stordif=storendmm[,4,2:nrun]-storendmm[,4,1] #difference in ending storage

```

Calcualte PET:
```{r PET_calc}
#Cacluate Beta and PET based on Beta
beta=PET=array(NA, dim=c(nval, nyear, nrun))
for(r in 1:nrun){
  print(r)
  for(y in 1:nyear){
      beta[,y,r]=((sm[,y,r]/porosity1)-0.2)/0.8
      beta[(beta[,y,r]<0),y,r]=0 #getting rid of the negative values where the saturation is less than sres
      PET[,y,r]=lhmm[,y,r]/beta[,y,r]
  }
}

#Read in the Baseline year7 PET calcualted from the daily SM and LH
fin="/Users/laura/Documents/CONUS/Warming_Runs/Simulation_Averages/Temp0_Year7/Baseline.Year7.PET_mm.yearly.bin"
print(fin)
to.read = file(fin, "rb")
header=readBin(to.read, integer(), endian = "little", size=4, n=3)
PETB7=readBin(to.read, double(), endian = "little", size=8, n=nval)
close(to.read)


```

## Aggregating by HUC
```{r HUC_agg}
#Aggregate by HUC
HUC_list=sort(unique(HUC_Merge))
nhuc=length(HUC_list)

#HUC Summary matrices
precipmm_HUC=area_HUC=rep(0, nhuc) #Summary matrix with a row for every HUC
lhmm_HUC=storendmm_HUC=PET_HUC=array(0, c(nhuc, nyear, nrun))
stordif_HUC=matrix(0, nrow=nhuc, ncol=(nrun-1))

#HUG grid matrices
lhmm_Hgrid=storendmm_Hgrid=PET_Hgrid=array(0, c(nval, nyear, nrun)) #matrix assigning the HUC sum value to every grid cell
stordif_Hgrid=array(0, c(nval, nrun-1) )#matrix assigning the HUC sum value to every grid cell
precipmm_Hgrid=area_Hgrid=rep(0, nval)
                     
#summing all of the matrix values
for(h in 1:nhuc){
  print(h)
  hnum=HUC_list[h]
  ilist=which(HUC_Merge==hnum)
  
  #Recording the HUC sums in the HUC matrix
  area_HUC[h]=length(ilist)
  
  if(length(ilist)>1){
    #Precipitation
    precipmm_HUC[h]=sum(precipmm[ilist])
    precipmm_Hgrid[ilist]= precipmm_HUC[h]
    
    #lhmm and storend sums
    for(r in 1:nrun){
      for(y in 1:nyear){
        lhmm_HUC[h,y,r]=sum(lhmm[ilist, y, r])
        lhmm_Hgrid[ilist,y,r]=lhmm_HUC[h,y,r]
        
        PET_HUC[h,y,r]=sum(PET[ilist, y, r])
        PET_Hgrid[ilist,y,r]=PET_HUC[h,y,r]
          
        storendmm_HUC[h,y,r]=sum(storendmm[ilist, y, r])
        storendmm_Hgrid[ilist,y,r]=storendmm_HUC[h,y,r]
      }
    }
    
    #stordif sum
    for(r in 1:(nrun-1)){
      stordif_HUC[h, r]=sum(stordif[ilist, r])
      stordif_Hgrid[ilist, r]=stordif_HUC[h, r]
    }
  } #end if
  
}

#zeroing out the values for the -999 HUC
stordif_HUC[1,]=NA
storendmm_HUC[1,,]=NA
lhmm_HUC[1,,]=NA
PET_HUC[1,,]=NA
precipmm_HUC[1]=NA

ilist=which(HUC_Merge==HUC_list[1])
stordif_Hgrid[ilist,]=NA
storendmm_Hgrid[ilist,,]=NA
lhmm_Hgrid[ilist,,]=NA
PET_Hgrid[ilist,,]=NA
precipmm_Hgrid[ilist]=NA

#Get the LH simulation totals over all 4 years
lhmm_Hgridtot=matrix(NA, nrow=nval, ncol=nrun)
for(r in 1:nrun){ 
	lhmm_Hgridtot[,r]=apply(lhmm_Hgrid[,,r], 1, sum )
}
```

## Gridded Plotting
Ending storage plot
```{r storend_plot, fig.width=8.1, fig.height=8.9, warning=FALSE}
#fout=paste(plotdir, "Ending_Storage_Diff.pdf", sep="")
#pdf(fout, width=8.1, height=8.9)
par(mfrow=c(2,1), mar=c(1,2,3,3))

maxz=0
minz=-100

#2 degree 
plottemp=stordif[,1]
plottemp[which(plottemp>maxz)]=maxz
plottemp[which(plottemp<minz)]=minz
rastertemp1=rasterFromXYZ(cbind(xUTM, yUTM, plottemp))
plot(rastertemp1, maxpixels=(nx*ny*10), col=rev(brewer.pal(name="YlOrRd", n=5)), colNA='lightblue',  legend=T, main="2 Degree Ending Storage dif [mm]", axes=F, zlim=c(minz, maxz))

#4 degree 
plottemp=stordif[,2]
plottemp[which(plottemp>maxz)]=maxz
plottemp[which(plottemp<minz)]=minz
rastertemp1=rasterFromXYZ(cbind(xUTM, yUTM, plottemp))
plot(rastertemp1, maxpixels=(nx*ny*10), col=rev(brewer.pal(name="YlOrRd", n=5)), colNA='lightblue',  legend=T, main="4 Degree Ending Storage dif [mm]", axes=F, zlim=c(minz, maxz))

#dev.off()

```

Total LH Flux plot
```{r LHtot_plot, fig.width=8.1, fig.height=8.9, warning=FALSE}
#fout=paste(plotdir, "LH_Total_Diff.pdf", sep="")
#pdf(fout, width=8.1, height=8.9)
par(mfrow=c(2,1), mar=c(1,2,3,3))

maxz=1000
minz=0

#2 degree 
plottemp=lhmm_tot[,2]-lhmm_tot[,1]
plottemp[which(plottemp>maxz)]=maxz
plottemp[which(plottemp<minz)]=minz
rastertemp1=rasterFromXYZ(cbind(xUTM, yUTM, plottemp))
plot(rastertemp1, maxpixels=(nx*ny*10), col=brewer.pal(name="YlGnBu", n=10), colNA='lightblue',  legend=T, main="2 Degree Total LH Difference [mm]", axes=F, zlim=c(minz, maxz))

#4 degree 
plottemp=lhmm_tot[,3]-lhmm_tot[,1]
plottemp[which(plottemp>maxz)]=maxz
plottemp[which(plottemp<minz)]=minz
rastertemp1=rasterFromXYZ(cbind(xUTM, yUTM, plottemp))
plot(rastertemp1, maxpixels=(nx*ny*10), col=brewer.pal(name="YlGnBu", n=10), colNA='lightblue',  legend=T, main="2 Degree Total LH Difference [mm]", axes=F, zlim=c(minz, maxz))

#dev.off()
```

Storage change divided by LH flux increase plot
```{r StorLH_plot, fig.width=8.1, fig.height=8.9, warning=FALSE}
#fout=paste(plotdir, "Storage_LH_Ratio.pdf", sep="")
#pdf(fout, width=8.1, height=8.9)
par(mfrow=c(2,1), mar=c(1,2,3,3))

maxz=0.5
minz=0

#2 degree 
plottemp=(-stordif[,1])/(lhmm_tot[,2]-lhmm_tot[,1]) #year for ending storage dif/ total LH dif
plottemp[which(plottemp>maxz)]=maxz
plottemp[which(plottemp<minz)]=minz
rastertemp1=rasterFromXYZ(cbind(xUTM, yUTM, plottemp))
plot(rastertemp1, maxpixels=(nx*ny*10), col=brewer.pal(name="YlGnBu", n=10), colNA='lightblue',  legend=T, main="2 Degree stordif/LH dif [mm]", axes=F, zlim=c(minz, maxz))

#4 degree 
plottemp=(-stordif[,2])/(lhmm_tot[,3]-lhmm_tot[,1])
plottemp[which(plottemp>maxz)]=maxz
plottemp[which(plottemp<minz)]=minz
rastertemp1=rasterFromXYZ(cbind(xUTM, yUTM, plottemp))
plot(rastertemp1, maxpixels=(nx*ny*10), col=brewer.pal(name="YlGnBu", n=10), colNA='lightblue',  legend=T, main="2 Degree stordif/LH dif[mm]", axes=F, zlim=c(minz, maxz))

#dev.off()
```

Aridity index
```{r AI plot, fig.width=8.1, fig.height=8.9, warning=FLASE }
par(oma=c( 0,0,0,4))
par(mfrow=c(2,1), mar=c(1,2,3,4))
maxz=7
minz=0
breaklist=c(0, 0.2, 0.4, 0.6, 0.8, 1,1.5,2,3,5,7)
collist=rev(brewer.pal(name="Spectral", n=10))


#Baseline simulation from yearly calcs
AIB=PET[,4,3]/precipmm #Baseline year7 PET/precip
plottemp=AIB
plottemp[which(plottemp>maxz)]=maxz
plottemp[which(plottemp<minz)]=minz
rastertemp1=rasterFromXYZ(cbind(xUTM, yUTM, plottemp))
image(rastertemp1, maxpixels=(nx*ny*10), col=collist,  main="Baseline AI (PET/P)", axes=F, zlim=c(minz, maxz), breaks=breaklist, xlab="", ylab="")
#plot(greatlakesUTM, add=T, col='lightgrey', border='lightgrey')
#plot(statshp, add=T, border='black')
box()
image.plot(legend.only=T, breaks=1:11, zlim=c(minz,maxz), col=collist, lab.breaks=breaklist, legend.width=2) #, legend.args=list( text="AI",cex=1, side=4, line=1))

#Baseline simulation from daily calcs
AIB=PETB7/precipmm #Baseline year7 PET/precip
plottemp=AIB
plottemp[which(plottemp>maxz)]=maxz
plottemp[which(plottemp<minz)]=minz
rastertemp1=rasterFromXYZ(cbind(xUTM, yUTM, plottemp))
image(rastertemp1, maxpixels=(nx*ny*10), col=collist,  main="Baseline AI (PET/P)", axes=F, zlim=c(minz, maxz), breaks=breaklist, xlab="", ylab="")
#plot(greatlakesUTM, add=T, col='lightgrey', border='lightgrey')
#plot(statshp, add=T, border='black')
box()
image.plot(legend.only=T, breaks=1:11, zlim=c(minz,maxz), col=collist, lab.breaks=breaklist, legend.width=2) #, legend.args=list( text="AI",cex=1, side=4, line=1))

```

Delta ET/Delta PET
```{r}
  #4 degree - year 1  
  y=1
  r=3
  dPET=PET[,y,r]-PET[,y,1]
  dET=lhmm[,y,r]-lhmm[,y,1]
  deltaratio=dET/dPET
  maxz=1
  minz=0
  
  par(mfrow=c(2,1), mar=c(1,2,3,3))

 
  plottemp=deltaratio 
  plottemp[which(plottemp>maxz)]=maxz
  plottemp[which(plottemp<minz)]=minz
  rastertemp1=rasterFromXYZ(cbind(xUTM, yUTM, plottemp))
  plot(rastertemp1, maxpixels=(nx*ny*10), col=brewer.pal(name="YlGnBu", n=9), colNA='lightblue',  legend=T, main="2 Degree stordif/LH dif [mm]", axes=F, zlim=c(minz, maxz))
  
  #4 degree - year 4 
  y=4
  r=3
  dPET=PET[,y,r]-PET[,y,1]
  dET=lhmm[,y,r]-lhmm[,y,1]
  deltaratio=dET/dPET
  maxz=1
  minz=0
  plottemp=deltaratio 
  plottemp[which(plottemp>maxz)]=maxz
  plottemp[which(plottemp<minz)]=minz
  rastertemp1=rasterFromXYZ(cbind(xUTM, yUTM, plottemp))
  plot(rastertemp1, maxpixels=(nx*ny*10), col=brewer.pal(name="YlGnBu", n=9), colNA='lightblue',  legend=T, main="2 Degree stordif/LH dif [mm]", axes=F, zlim=c(minz, maxz))
  
```
 
Scatter plot of dET/dPET compared to aridity and change in storage
```{r}
  #Coloring by the equivalent depth of storage change
  #colvar=(storendmm_HUC[,y,r]-storendmm_HUC[,y,1])/area_HUC #Difference in ending storage averaged over the HUC area
  #colvar=AI
  #rbPal = brewer.pal(name="Spectral", n=10)
  #rbPal = brewer.pal(name="YlOrRd", n=9)
  #breakpoints=seq(0,7,by=0.7)
  #breakpoints=seq(-90,0,by=10)
  #nbreak=length(breakpoints)
  #bins=as.numeric(cut(colvar, breaks=breakpoints, right=T, include.lowest=T))
  #collist = rbPal[bins]

  y=4
  r=3
  dPET=PET_HUC[,y,r]-PET_HUC[,y,1]
  dET=lhmm_HUC[,y,r]-lhmm_HUC[,y,1]
  deltaratio=dET/dPET #Change in ET/ Change in PET
  AI=PET_HUC[,y,1]/precipmm_HUC #Baseline run aridity index
  

  plot(AI, deltaratio, type='p', xlim=c(0,7), ylim=c(0,1), xlab="Baseline Aridity Index", ylab="dET/dPET", pch=16, cex=0.6, col='blue', main=c("Year 4 - ET Sensitivity vs Aridity"))
  legend('topright', legend=c("4 degree", "2 degree"), pch=rep(16,2),  col=c("blue", "black"), bty='n', cex=1.2)
  
  # Year 3
  #y=3
  #r=3
  #dPET=PET_HUC[,y,r]-PET_HUC[,y,1]
  #dET=lhmm_HUC[,y,r]-lhmm_HUC[,y,1]
  #deltaratio=dET/dPET #Change in ET/ Change in PET
  #AI=PET_HUC[,y,1]/precipmm_HUC #Baseline run aridity index
  #points(AI, deltaratio,  pch=16, cex=0.5, col='lightblue')
  
  # Year 2
  #y=2
  #r=3
  #dPET=PET_HUC[,y,r]-PET_HUC[,y,1]
  #dET=lhmm_HUC[,y,r]-lhmm_HUC[,y,1]
  #deltaratio=dET/dPET #Change in ET/ Change in PET
  #AI=PET_HUC[,y,1]/precipmm_HUC #Baseline run aridity index
  #points(AI, deltaratio,  pch=16, cex=0.5, col='darkgreen')
  
  # Year 1
  y=4
  r=2
  dPET=PET_HUC[,y,r]-PET_HUC[,y,1]
  dET=lhmm_HUC[,y,r]-lhmm_HUC[,y,1]
  deltaratio=dET/dPET #Change in ET/ Change in PET
  AI=PET_HUC[,y,1]/precipmm_HUC #Baseline run aridity index
  points(AI, deltaratio,  pch=16, cex=0.5, col='black')

  
```


## HUC Plotting
Aridity index by HUC
```{r AI_HUC, warning=FALSE}

  AI_Hgrid=PET_Hgrid[,4,1]/precipmm_Hgrid

  #AI_HUC=PET_HUC[,4,3]/lhmm_HUC[,4,3]
  #AI_Hgrid=PET[,4,1]/precipmm
  maxz=7
  minz=0

  #color list if you want to just break at o.8 and 1.2
  #breaklist=c(0, 0.8, 1, 1.2,7)
  #collist=rev(c('#e08214', '#fdb863', '#b2abd2', '#8073ac'))
  
  #collist=c('#eff3ff', '#abdda4', '#fdae61', "#fee5d9" )
  #collist=rev(c('#e66101', '#fdb863', '#b2abd2', '#5e3c99'))
  #collist=rev(c('#fdb863', '#fee0b6', '#d8daeb', '#b2abd2'))
  #collist=(rev(brewer.pal(name="Spectral", n=4)))

  #complete color list
  breaklist=c(0, 0.2, 0.4, 0.6, 0.8, 1,1.5,2,3,5,7)
  collist=rev(brewer.pal(name="Spectral", n=10))

  #Baseline
  plottemp=AI_Hgrid
  plottemp[which(plottemp>maxz)]=maxz
  plottemp[which(plottemp<minz)]=minz
  rastertemp1=rasterFromXYZ(cbind(xUTM, yUTM, plottemp))
    par(mar=c(1,2,3,5))
  image(rastertemp1, maxpixels=(nx*ny*10), col=collist,  main="a) Baseline AI (PET/P)", axes=F, zlim=c(minz, maxz), breaks=breaklist, xlab="", ylab="")
#plot(greatlakesUTM, add=T, col='lightgrey', border='black')
#plot(statshp, add=T, border='black')
box()
image.plot(legend.only=T, breaks=1:11, zlim=c(minz,maxz), col=collist, lab.breaks=breaklist, legend.width=2, smallplot= c(.87,0.93,0.05,0.85)) #, legend.args=list( text="AI",cex=1, side=4, line=1)) #use if you do the 0.8, 1.2 

```

Storage change divided by LH flux increase plot
```{r StorLH_HUC, fig.width=8.1, fig.height=8.9, warning=FALSE}
#fout=paste(plotdir, "Storage_LH_Ratio.pdf", sep="")
#pdf(fout, width=8.1, height=8.9)
par(mfrow=c(2,1), mar=c(1,2,3,3))

maxz=0.2
minz=0

#make a mask for aridity index <1
PET_Mask=rep(NA,nval)
PET_Mask[AI_Hgrid<=1.5]=1

#2 degree 
plottemp=(-stordif_Hgrid[,1])/(lhmm_Hgridtot[,2]-lhmm_Hgridtot[,1]) #year for ending storage dif/ total LH dif
plottemp[which(plottemp>maxz)]=maxz
plottemp[which(plottemp<minz)]=minz
plottemp=plottemp*PET_Mask
rastertemp1=rasterFromXYZ(cbind(xUTM, yUTM, plottemp))
plot(rastertemp1, maxpixels=(nx*ny*10), col=brewer.pal(name="YlGnBu", n=10), colNA='lightgrey',  legend=T, main="2 Degree stordif/LH dif [mm]", axes=F, zlim=c(minz, maxz))

#4 degree 
plottemp=(-stordif_Hgrid[,2])/(lhmm_Hgridtot[,3]-lhmm_Hgridtot[,1])
plottemp[which(plottemp>maxz)]=maxz
plottemp[which(plottemp<minz)]=minz
plottemp=plottemp*PET_Mask
rastertemp1=rasterFromXYZ(cbind(xUTM, yUTM, plottemp))
plot(rastertemp1, maxpixels=(nx*ny*10), col=brewer.pal(name="YlGnBu", n=10), colNA='lightgrey',  legend=T, main="2 Degree stordif/LH dif[mm]", axes=F, zlim=c(minz, maxz))

#dev.off()
```
